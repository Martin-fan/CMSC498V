<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>CMSC498V - Monads</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">CMSC498V</a>
            </div>
            <div id="navigation">
                <a href="../schedule.html">Schedule</a>
                <a href="../homeworks.html">Homeworks</a>
                <a href="../project.html">Projects</a>
                <a href="../resources.html">Resources</a>
            </div>
        </div>

        <div id="content">
            <h1 id="monads">Monads</h1>
<p>After Monoids, Applicatives and Functors, we are ready to learn what Monads are. But, instead of starting with the monadic class definition, let’s start by an example that is actually using monads in a hidden way.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Monads</span> <span class="kw">where</span></code></pre></div>
<h2 id="a-simple-evaluator">A Simple Evaluator</h2>
<p>Consider the following simple language of expressions that are built up from integer values using a division operator:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Val</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Div</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
<span class="ot">&gt;</span>           <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<p>Such expressions can be evaluated as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; eval1              ::</span>  <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> eval1 (<span class="dt">Val</span> n)     <span class="fu">=</span>  n
<span class="ot">&gt;</span> eval1 (<span class="dt">Div</span> x y)   <span class="fu">=</span>  eval1 x <span class="ot">`div`</span> eval1 y</code></pre></div>
<p>However, this function doesn’t take account of the possibility of division by zero, and will produce an error in this case.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> eval (<span class="dt">Div</span> (<span class="dt">Val</span> <span class="dv">1</span>) (<span class="dt">Val</span> <span class="dv">0</span>))
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> divide by zero </code></pre></div>
<p>In order to deal with this explicitly, we can use the <code>Maybe</code> type</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">|</span> <span class="dt">Just</span> a</code></pre></div>
<p>to define a safe version of division</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; safeDiv     ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> safeDiv n m <span class="fu">=</span>  <span class="kw">if</span> m <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Nothing</span> <span class="kw">else</span> <span class="dt">Just</span> (n <span class="ot">`div`</span> m)</code></pre></div>
<p>and then modify our evaluator as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; eval1' ::</span>  <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> eval1' (<span class="dt">Val</span> n)   <span class="fu">=</span>  <span class="dt">Just</span> n
<span class="ot">&gt;</span> eval1' (<span class="dt">Div</span> x y) <span class="fu">=</span>  <span class="kw">case</span> eval1' x <span class="kw">of</span>
<span class="ot">&gt;</span>                        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>                        <span class="dt">Just</span> n1 <span class="ot">-&gt;</span> <span class="kw">case</span> eval1' y <span class="kw">of</span>
<span class="ot">&gt;</span>                                     <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>                                     <span class="dt">Just</span> n2 <span class="ot">-&gt;</span> n1 <span class="ot">`safeDiv`</span> n2</code></pre></div>
<p><strong>Q:</strong> What happens now to our previous exception?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> eval1' (<span class="dt">Div</span> (<span class="dt">Val</span> <span class="dv">1</span>) (<span class="dt">Val</span> <span class="dv">0</span>))</code></pre></div>
<p>As in the previous section, we can observe a common pattern, namely performing a case analysis on a value of a <code>Maybe</code> type, mapping <code>Nothing</code> to itself, and <code>Just x</code> to some result depending upon <code>x</code>. (Aside: we could go further and also take account of the fact that the case analysis is performed on the result of an eval, but this would lead to the more advanced notion of a monadic fold.)</p>
<p>How should this pattern be abstracted out? One approach would be to observe that a key notion in the evaluation of division is the sequencing of two values of a <code>Maybe</code> type, namely the results of evaluating the two arguments of the division. Based upon this observation, we could define a sequencing function</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; seqn                    ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)
<span class="ot">&gt;</span> seqn <span class="dt">Nothing</span>   _        <span class="fu">=</span>  <span class="dt">Nothing</span>
<span class="ot">&gt;</span> seqn _         <span class="dt">Nothing</span>  <span class="fu">=</span>  <span class="dt">Nothing</span>
<span class="ot">&gt;</span> seqn (<span class="dt">Just</span> x)  (<span class="dt">Just</span> y) <span class="fu">=</span>  <span class="dt">Just</span> (x, y)</code></pre></div>
<p>using which our evaluator can now be defined more compactly:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; eval2           ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> eval2 (<span class="dt">Val</span> n)   <span class="fu">=</span> <span class="dt">Just</span> n
<span class="ot">&gt;</span> eval2 (<span class="dt">Div</span> x y) <span class="fu">=</span> apply f (eval2 x <span class="ot">`seqn`</span> eval2 y)
<span class="ot">&gt;</span>                    <span class="kw">where</span> f (n, m) <span class="fu">=</span> safeDiv n m</code></pre></div>
<p><strong>Q:</strong> What must the type of apply be for the above to typecheck?</p>
<p>The auxiliary function <code>apply</code> is an analogue of application for <code>Maybe</code>, and is used to process the results of the two evaluations:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; apply            ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b
<span class="ot">&gt;</span> apply f <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span> apply f (<span class="dt">Just</span> x) <span class="fu">=</span> f x</code></pre></div>
<p>In practice, however, using <code>seqn</code> can lead to programs that manipulate nested tuples, which can be messy. For example, the evaluation of an operator <code>Op</code> with three arguments may be defined by:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">eval (<span class="dt">Op</span> x y z) <span class="fu">=</span> map f (eval x <span class="ot">`seqn`</span> (eval y <span class="ot">`seqn`</span> eval z))
                    <span class="kw">where</span> f (a, (b, c)) <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
<h2 id="combining-sequencing-and-processing">Combining Sequencing and Processing</h2>
<p>The problem of nested tuples can be avoided by returning to our original observation of a common pattern:</p>
<ul>
<li>performing a case analysis on a value of a <code>Maybe</code> type,</li>
<li>mapping <code>Nothing</code> to <code>Nothing</code>, and</li>
<li>mapping <code>Just x</code> to some result depending upon <code>x</code>.</li>
</ul>
<p>Abstract this pattern directly gives a new sequencing operator that we write as <code>(&gt;&gt;=)</code>, and read as “then”:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;=)   ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b
m <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span>  <span class="kw">case</span> m <span class="kw">of</span>
             <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
             <span class="dt">Just</span> x  <span class="ot">-&gt;</span> f x</code></pre></div>
<p>Replacing the use of case analysis by pattern matching gives a more compact definition for this operator:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;=)          ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b
<span class="dt">Nothing</span>  <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> <span class="dt">Nothing</span>
(<span class="dt">Just</span> x) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f x</code></pre></div>
<p>That is, if the first argument is <code>Nothing</code> then the second argument is ignored and <code>Nothing</code> is returned as the result. Otherwise, if the first argument is of the form <code>Just x</code>, then the second argument is applied to <code>x</code> to give a result of type <code>Maybe b</code>.</p>
<p>The <code>(&gt;&gt;=)</code> operator avoids the problem of nested tuples of results because the result of the first argument is made directly available for processing by the second, rather than being paired up with the second result to be processed later on. In this manner, <code>(&gt;&gt;=)</code> integrates the sequencing of values of type <code>Maybe</code> with the processing of their result values. In the literature, <code>(&gt;&gt;=)</code> is often called <strong>bind</strong>, because the second argument binds the result of the first.</p>
<p>Using <code>(&gt;&gt;=)</code>, our evaluator can now be rewritten as:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> eval (<span class="dt">Val</span> n)   <span class="fu">=</span> <span class="dt">Just</span> n
<span class="ot">&gt;</span> eval (<span class="dt">Div</span> x y) <span class="fu">=</span> eval x <span class="fu">&gt;&gt;=</span> (\n <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>                    eval y <span class="fu">&gt;&gt;=</span> (\m <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>                      safeDiv n m
<span class="ot">&gt;</span>                    )
<span class="ot">&gt;</span>                  )</code></pre></div>
<p>The case for division can be read as follows: evaluate <code>x</code> and call its result value <code>n</code>, then evaluate <code>y</code> and call its result value <code>m</code>, and finally combine the two results by applying <code>safeDiv</code>. In fact, the scoping rules for lambda expressions mean that the parentheses in the case for division can freely be omitted.</p>
<p>Generalising from this example, a typical expression built using the <code>(&gt;&gt;=)</code> operator has the following structure:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">m1 <span class="fu">&gt;&gt;=</span> \x1 <span class="ot">-&gt;</span>
  m2 <span class="fu">&gt;&gt;=</span> \x2 <span class="ot">-&gt;</span>
  <span class="fu">...</span>
    mn <span class="fu">&gt;&gt;=</span> \xn <span class="ot">-&gt;</span>
      f x1 x2 <span class="fu">...</span> xn</code></pre></div>
<p>That is, evaluate each of the expression <code>m1</code>, <code>m2</code>,…,<code>mn</code> in turn, and combine their result values <code>x1</code>, <code>x2</code>,…, <code>x</code>n by applying the function <code>f</code>. The definition of <code>(&gt;&gt;=)</code> ensures that such an expression only succeeds (returns a value built using <code>Just</code>) if each <code>mi</code> in the sequence succeeds.</p>
<p>In other words, the programmer does not have to worry about dealing with the possible failure (returning <code>Nothing</code>) of any of the component expressions, as this is handled automatically by the <code>(&gt;&gt;=)</code> operator.</p>
<p>Haskell provides a special notation for expressions of the above structure, allowing them to be written in a more appealing form:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> x1 <span class="ot">&lt;-</span> m1
   x2 <span class="ot">&lt;-</span> m2
   <span class="fu">...</span>
   xn <span class="ot">&lt;-</span> mn
   f x1 x2 <span class="fu">...</span> xn</code></pre></div>
<p>Hence, for example, our evaluator can be redefined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">eval (<span class="dt">Val</span> n)   <span class="fu">=</span> <span class="dt">Just</span> n
eval (<span class="dt">Div</span> x y) <span class="fu">=</span> <span class="kw">do</span> n <span class="ot">&lt;-</span> eval x
                    m <span class="ot">&lt;-</span> eval y
                    safediv n m</code></pre></div>
<p><strong>Q:</strong> Show that the version of eval defined using <code>(&gt;&gt;=)</code> is equivalent to our original version, by expanding the definition of <code>(&gt;&gt;=)</code>.</p>
<p><strong>Q:</strong> Redefine <code>seqn x y</code> and <code>eval (Op x y z)</code> using the do notation.</p>
        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
