\begin{code}
module HW3 where
\end{code}

Problem 1: Configurations are monoids 
----------

Haskell config data type
  - enable optimizations?
  - language extentions
  - number of threads
  
```
data Config = Config { cOpt :: Bool, cExt :: [String], cThreads :: Int }
```

  1. Define a monoid instance 
  2. Definite a wrong monoid instance (that violates the monoid laws) (this should be quickcheckable)
  3. In the class we saw that Bools and Ints are monoids with (+ or *) and (|| or &&). 
  Modify the definition of Config so that the monoid instance can be automatically generated by 
     https://hackage.haskell.org/package/generic-deriving-1.11.2/docs/Generics-Deriving-Monoid.html
     
     
Problem 2: Parallelization
---

This is to get used to parallelization and the library we use for paralelism 
https://hackage.haskell.org/package/parallel-3.2.1.1/docs/Control-Parallel-Strategies.html#t:Strategy


1. Something about NFData?

2. Define the function 
```
pmap :: NFData a => (a -> b) -> [a] -> [b]
pmap f xs = withStrategy (rparWith rdeepseq) (map f xs)
```

3. Use pmap somehow.


Problem 3: Map Reduce


1. In class we saw 


< mapReduce :: (Chunkable a, Monoid b) 
<           => (a -> b) -> (a -> b)

and claimed that forall f and x

< mapReduce f x == f x
only when the monoid laws are satified. 
Define a parallelizable function whose range breaks the monoid lows, 
so that 
< mapReduce f x /= f x


2. Define the Parallelizable type class

Define the type class so that 
< parallelize :: (Parallelizable a b) => (a -> b) -> a -> b
and 
< psum = parallelize sum
< for all lists. psum xs == sum xs

3. Parallelize some algorithm (I think quicheck is too diffucult, but sum is too easy. )
